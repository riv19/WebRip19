# Reference versions:
#
# SVT-AV1-HDR v3.1.2-216-g28963672 (release)
# opus-tools 0.2
# avifenc 1.3.0
# yt-dlp 2025.08.27
# vspipe Core R72
# ffmpeg version n8.0.1
# mpv v0.40.0-dirty
# MPlayer SVN-r38542
# ffmpeg-normalize v1.33.1

set -euo pipefail

PLAYLIST="$PWD/playlist.m3u"
TMPDIR=~/.WebRip19
LOG_FILE=webrip19.log
SCRIPT_URL="https://github.com/riv19/WebRip19"

# Download options

YTDLP_ARGS_0=( --extractor-args "youtube:player-client=tv_embedded" \
    --cookies "$PWD/www.youtube.com_cookies.txt" \
    --abort-on-unavailable-fragments \
    --write-subs --sub-format srt --sub-langs "en,uk,ru" \
    --embed-chapters --write-info-json --write-description  \
    --user-agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:142.0) Gecko/20100101 Firefox/142.0" \
    -S vcodec:h264 )
YTDLP_ARGS_1=( --extractor-args "youtube:player_client=default,ios;formats=missing_pot" \
    -S "tbr" -f "bv*+ba*[acodec=opus]" \
    --abort-on-unavailable-fragments \
    --write-subs --sub-format srt --sub-langs "en,uk,ru" \
    --embed-chapters --write-info-json --write-description  \
    --user-agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:142.0) Gecko/20100101 Firefox/142.0")
YTDLP_ARGS_DEFAULT=( --embed-chapters --write-info-json --write-description \
    --write-subs --sub-format srt --abort-on-unavailable-fragments )

YTDLP_ARGS=( "${YTDLP_ARGS_DEFAULT[@]}" ) # Choose the template from above

# Audio decoding options

# * Vapoursynth provides basic audio support, using FFMPEG internally.
# * FFMPEG
# * MPV
# * MPlayer

VAPOURSYNTH_AUDIO_SCRIPT=audio.vpy

AUDIO_DECODERS=( vspipe ffmpeg mpv mplayer )
AUDIO_DECODER="${AUDIO_DECODERS[2]}" # MPV

FFMPEG_AUDIO_ARGS1=( -acodec pcm_s16le )
FFMPEG_AUDIO_ARGS=( "${FFMPEG_AUDIO_ARGS1[@]}" )

MPV_AUDIO_ARGS1=( --audio-format=s16 )
MPV_AUDIO_ARGS=( "${MPV_AUDIO_ARGS1[@]}" )

MPLAYER_AUDIO_ARGS1=( -af format=s16le )
MPLAYER_AUDIO_ARGS=( "${MPLAYER_AUDIO_ARGS1[@]}" )

# Video decoding options

# * Vapoursynth provides plenty of plugins and scripting, however it may be
#   difficult to install and use.
# * FFMPEG may have less filters, but very strong in decoding various formats.
# * MPV is the modern MPlayer's fork which can be used for trivial filtering.
# * MPlayer is obsolete: it does not support yuv420p10 pixel format. Use only
#   to intentially get yuv420p8 resulting files (more banding effect).

VAPOURSYNTH_VIDEO_SCRIPT=hq.vpy

VIDEO_DECODERS=( vspipe ffmpeg mpv mplayer )
VIDEO_DECODER="${VIDEO_DECODERS[2]}" # MPV

FFMPEG_VIDEO_ARGS1=( -vf scale=%%VIDEO_WIDTH%%:%%VIDEO_HEIGHT%% -pix_fmt yuv420p10le -strict -1 )
FFMPEG_VIDEO_ARGS=( "${FFMPEG_VIDEO_ARGS1[@]}" )

MPV_VIDEO_ARGS1=( --vf=scale=%%VIDEO_WIDTH%%:%%VIDEO_HEIGHT%% --vf=format=yuv420p10le )
MPV_VIDEO_ARGS2=( --vf=eq=contrast=-0.05:brightness=-0.05,scale=%%VIDEO_WIDTH%%:%%VIDEO_HEIGHT%% -vf=format=yuv420p10le )
MPV_VIDEO_ARGS=( "${MPV_VIDEO_ARGS1[@]}" )

MPLAYER_VIDEO_ARGS1=( -vf scale=%%VIDEO_WIDTH%%:%%VIDEO_HEIGHT%% )
MPLAYER_VIDEO_ARGS2=( -vf eq=-5:-5,scale=%%VIDEO_WIDTH%%:%%VIDEO_HEIGHT%% )
MPLAYER_VIDEO_ARGS=( "${MPLAYER_VIDEO_ARGS1[@]}" )

# Cover image encoding options

# Svt is crashing for me in avif mode.
# AOM's tune=iq equals to svt-psy tune=4 (Still Picture)
AVIFENC_ARGS=( -q 51 -c aom -s 0 -j 4 -d 10 -y 420 -a tune=iq )

# Video encoding options

# SVT AV1 HDR encoder.
# Options below are for real footage content, adjust the following:
# --preset <below 4>
# --crf <up to 45>
# Restoration and CDEF filters work better for cartoons and anime.
SVT_AV1_HDR_ARGS=( --crf 35 --preset 8 --tune 2 --alt-ssim-tuning 1 \
                   --enable-overlays 1 --complex-hvs 1 --scm 1 --enable-tf 1 \
                   --tf-strength 1 --enable-restoration 0 --enable-cdef 0 \
                   --enable-dlf 2 --ac-bias 4.0 --spy-rd 1 \
                   --enable-variance-boost 1 --variance-boost-strength 2 \
                   --noise-norm-strength 3 --variance-boost-curve 0 )

FFMPEG_VAAPI_CODECS=( mjpeg_vaapi mpeg2_vaapi h264_vaapi hevc_vaapi \
                      vp8_vaapi vp9_vaapi av1_vaapi )
FFMPEG_VAAPI_CODEC="${FFMPEG_VAAPI_CODECS[3]}" # HEVC

FFMPEG_MEDIACODEC_CODECS=( mpeg4_mediacodec h264_mediacodec hevc_mediacodec \
                           vp8_mediacodec vp9_mediacodec av1_mediacodec )
FFMPEG_MEDIACODEC_CODEC="${FFMPEG_MEDIACODEC_CODECS[2]}" # HEVC

# 10-bit HEVC HW support (verified):
# AMD Ryzen 5 and above, Google Pixel 9.
# 8-bit VP9 HW support:
# Huawei Kirin 985.
FFMPEG_HW_PIXFMTS=( nv12 p010le )
FFMPEG_HW_PIXFMT="${FFMPEG_HW_PIXFMTS[1]}" # 10-bit

# 8-bit and 10-bit pixel formats for software codecs.
FFMPEG_SW_PIXFMTS=( yuv420p yuv420p10le )
FFMPEG_SW_PIXFMT="${FFMPEG_SW_PIXFMTS[1]}" # 10-bit

# VAAPI HW accelerated encoder.
# Use for quick archiving, to re-encode efficiently later.
# qp=1 is near lossless compression.
FFMPEG_VENC_ARGS_VAAPI=( -vaapi_device /dev/dri/renderD128 \
                         -vf "format=$FFMPEG_HW_PIXFMT,hwupload" \
                         -c:v $FFMPEG_VAAPI_CODEC -qp 1 )

# MediaCodec API HW accelerated encoder for Android (Termux).
# Different hardware require different options for near-lossless quality.
FFMPEG_VENC_ARGS_MEDIACODEC=( -c:v $FFMPEG_MEDIACODEC_CODEC \
                              -bitrate_mode vbr -b:v 500M \
                              -vf "format=$FFMPEG_HW_PIXFMT" )

# Software lossless VP9.
FFMPEG_VENC_ARGS_LIBVPX_VP9=( -c:v libvpx-vp9 -lossless 1 \
                              -vf "format=$FFMPEG_SW_PIXFMT" )

# Select FFMPEG video codec here
FFMPEG_VENC_ARGS=("${FFMPEG_VENC_ARGS_VAAPI[@]}")
#FFMPEG_VENC_ARGS=("${FFMPEG_VENC_ARGS_MEDIACODEC[@]}")
#FFMPEG_VENC_ARGS=("${FFMPEG_VENC_ARGS_LIBVPX_VP9[@]}")

VIDEO_ENCODERS=( copy ffmpeg svt_av1_hdr )
VIDEO_ENCODER="${VIDEO_ENCODERS[2]}" # svt_av1_hdr

# Audio processing options

# Enable Dynamic Range Compression on audio tracks:
# It ts useful for podcasts where speach volume from different people is not
# consistent. Requires installation of the whole ffmpeg dependency set.
DRC=0
FFMPEG_NORMALIZE_ARGS=( -t -15 --dynamic )

# Audio encoding options

OPUSENC_ARGS=( --bitrate 80 )

AUDIO_ENCODERS=( copy opusenc )
AUDIO_ENCODER="${AUDIO_ENCODERS[1]}"

# Output file options
